"""
AWS Bedrock AI Service for Alert Triage
Uses Claude 3.5 Sonnet via AWS Bedrock for intelligent alert analysis
"""

import boto3
import json
import os
from typing import Dict, List
from backend.models import Alert, RemediationPlan
from botocore.exceptions import ClientError


class BedrockService:
    """
    LLM service using AWS Bedrock with Claude 3.5 Sonnet
    Analyzes alerts and generates safe remediation scripts
    """

    def __init__(self):
        # AWS credentials from environment
        self.aws_region = os.getenv("AWS_REGION", "us-east-1")
        self.aws_access_key = os.getenv("AWS_ACCESS_KEY_ID")
        self.aws_secret_key = os.getenv("AWS_SECRET_ACCESS_KEY")
        self.aws_session_token = os.getenv(
            "AWS_SESSION_TOKEN"
        )  # For SSO/temporary credentials

        # Initialize Bedrock Runtime client
        # boto3 will automatically use credentials in this order:
        # 1. Explicit credentials from .env (if provided)
        # 2. AWS CLI credentials (~/.aws/credentials)
        # 3. IAM role (if running on EC2/Lambda)
        # 4. SSO credentials (if aws sso login was used)
        try:
            client_kwargs = {
                "service_name": "bedrock-runtime",
                "region_name": self.aws_region,
            }

            # Only add explicit credentials if they're set in .env
            # Otherwise, boto3 will use AWS CLI/SSO credentials automatically
            if self.aws_access_key and self.aws_secret_key:
                client_kwargs["aws_access_key_id"] = self.aws_access_key
                client_kwargs["aws_secret_access_key"] = self.aws_secret_key

                # Add session token if present (for temporary/SSO credentials)
                if self.aws_session_token:
                    client_kwargs["aws_session_token"] = self.aws_session_token
                    print("[OK] Using temporary/SSO credentials from .env")
                else:
                    print("[OK] Using permanent credentials from .env")
            else:
                print(
                    "[OK] Using AWS CLI/SSO credentials (no explicit credentials in .env)"
                )

            self.bedrock = boto3.client(**client_kwargs)
            print(f"[OK] AWS Bedrock client initialized (region: {self.aws_region})")
        except Exception as e:
            raise ValueError(
                f"Failed to initialize AWS Bedrock client: {str(e)}\n\n"
                f"Troubleshooting:\n"
                f"1. For SSO: Run 'aws sso login' first\n"
                f"2. For temp credentials: Add AWS_SESSION_TOKEN to .env\n"
                f"3. For permanent credentials: Add AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY to .env"
            )

        # Amazon Nova Pro - AWS-native AI model
        # Benefits: Immediately available, no approval needed, cost-effective, AWS-native
        self.model_id = "amazon.nova-pro-v1:0"
        self.model_name = "Amazon Nova Pro"

        # Fallback cache for demo reliability
        self.use_cache = os.getenv("USE_CACHED_RESPONSES", "false").lower() == "true"
        self.cached_responses = self._load_cached_responses()

    def _load_cached_responses(self) -> Dict:
        """
        Load pre-cached demo responses as fallback
        Used when USE_CACHED_RESPONSES=true or if API fails
        """
        return {
            "INC0012345": {
                "root_cause": "IIS logs accumulating in C:\\inetpub\\logs consuming excessive disk space",
                "confidence": 0.92,
                "reasoning": "Historical pattern shows similar incident on 2025-09-15 where disk space reached 92%. Current metrics indicate rapid growth in log directory size. Device history confirms IIS logs are primary contributor. SOP recommends archiving logs older than 30 days as standard remediation.",
                "steps": [
                    "Identify IIS log files older than 30 days in C:\\inetpub\\logs\\LogFiles",
                    "Create backup directory at D:\\Backups\\IISLogs for retention compliance",
                    "Copy old logs to backup location before deletion",
                    "Safely delete old log files with comprehensive error handling",
                    "Verify disk space reduction and confirm operations successful",
                    "Update monitoring threshold if disk usage normalized",
                ],
                "script": """# Disk Space Cleanup Script - IIS Logs
# Generated by Agentic Alert Triage Assistant
# Alert ID: INC0012345
# Safety: Creates backup before deletion, includes error handling

Write-Host "Starting disk cleanup on C:\\" -ForegroundColor Green
Write-Host "Target: IIS logs older than 30 days" -ForegroundColor Yellow
Write-Host "=" * 60 -ForegroundColor Gray

$LogPath = "C:\\inetpub\\logs\\LogFiles"
$DaysToKeep = 30
$CutoffDate = (Get-Date).AddDays(-$DaysToKeep)
$BackupPath = "D:\\Backups\\IISLogs"

try {
    # Safety check: Ensure path exists
    Write-Host "Checking log path..." -ForegroundColor Cyan
    if (-not (Test-Path $LogPath)) {
        Write-Host "ERROR: Log path not found - $LogPath" -ForegroundColor Red
        Write-Host "This may indicate IIS is not installed or logs are in different location" -ForegroundColor Yellow
        exit 1
    }

    Write-Host "✓ Log path verified: $LogPath" -ForegroundColor Green

    # Find old logs
    Write-Host "Scanning for logs older than $DaysToKeep days..." -ForegroundColor Cyan
    $OldLogs = Get-ChildItem -Path $LogPath -Recurse -File |
               Where-Object { $_.LastWriteTime -lt $CutoffDate }

    if ($OldLogs.Count -eq 0) {
        Write-Host "No old logs found. Disk space issue may be elsewhere." -ForegroundColor Yellow
        Write-Host "Consider checking:" -ForegroundColor Yellow
        Write-Host "  - Application logs" -ForegroundColor Gray
        Write-Host "  - Temp directories" -ForegroundColor Gray
        Write-Host "  - Database files" -ForegroundColor Gray
        exit 0
    }

    $TotalSize = ($OldLogs | Measure-Object -Property Length -Sum).Sum / 1GB
    $TotalSizeRounded = [math]::Round($TotalSize, 2)

    Write-Host "✓ Found $($OldLogs.Count) files totaling $TotalSizeRounded GB" -ForegroundColor Green
    Write-Host ""

    # Create backup directory (safety measure)
    Write-Host "Preparing backup location..." -ForegroundColor Cyan
    if (-not (Test-Path $BackupPath)) {
        New-Item -ItemType Directory -Force -Path $BackupPath | Out-Null
        Write-Host "✓ Created backup directory: $BackupPath" -ForegroundColor Green
    } else {
        Write-Host "✓ Backup directory exists: $BackupPath" -ForegroundColor Green
    }

    # Backup old logs (optional but recommended for compliance)
    Write-Host ""
    Write-Host "Creating backup of logs before deletion..." -ForegroundColor Yellow
    Write-Host "This may take a few moments..." -ForegroundColor Gray

    $BackupCount = 0
    foreach ($log in $OldLogs) {
        try {
            Copy-Item -Path $log.FullName -Destination $BackupPath -Force -ErrorAction Stop
            $BackupCount++

            # Progress indicator every 50 files
            if ($BackupCount % 50 -eq 0) {
                Write-Host "  Backed up $BackupCount files..." -ForegroundColor Gray
            }
        } catch {
            Write-Host "Warning: Could not backup $($log.Name): $($_.Exception.Message)" -ForegroundColor Yellow
        }
    }

    Write-Host "✓ Backup complete: $BackupCount files backed up" -ForegroundColor Green
    Write-Host ""

    # Delete old logs
    Write-Host "Deleting old logs..." -ForegroundColor Yellow
    $DeletedCount = 0
    $DeletedSize = 0

    foreach ($log in $OldLogs) {
        try {
            $fileSize = $log.Length
            Remove-Item -Path $log.FullName -Force -ErrorAction Stop
            $DeletedCount++
            $DeletedSize += $fileSize

            # Progress indicator
            if ($DeletedCount % 50 -eq 0) {
                $deletedGB = [math]::Round($DeletedSize / 1GB, 2)
                Write-Host "  Deleted $DeletedCount files ($deletedGB GB)..." -ForegroundColor Gray
            }
        } catch {
            Write-Host "Warning: Could not delete $($log.Name): $($_.Exception.Message)" -ForegroundColor Yellow
        }
    }

    $FinalDeletedSize = [math]::Round($DeletedSize / 1GB, 2)
    Write-Host "✓ Cleanup complete" -ForegroundColor Green
    Write-Host "  Files deleted: $DeletedCount" -ForegroundColor Cyan
    Write-Host "  Space freed: $FinalDeletedSize GB" -ForegroundColor Cyan
    Write-Host ""

    # Verify new disk usage
    Write-Host "Verifying disk space..." -ForegroundColor Cyan
    $Disk = Get-PSDrive C
    $UsedPercent = [math]::Round(($Disk.Used / ($Disk.Used + $Disk.Free)) * 100, 2)
    $UsedGB = [math]::Round($Disk.Used / 1GB, 2)
    $FreeGB = [math]::Round($Disk.Free / 1GB, 2)

    Write-Host "Current disk usage:" -ForegroundColor Cyan
    Write-Host "  Used: $UsedGB GB ($UsedPercent%)" -ForegroundColor $(if ($UsedPercent -lt 80) { "Green" } else { "Yellow" })
    Write-Host "  Free: $FreeGB GB" -ForegroundColor Green
    Write-Host ""

    if ($UsedPercent -lt 80) {
        Write-Host "SUCCESS: Disk usage now within acceptable range" -ForegroundColor Green
        Write-Host "Alert can be marked as RESOLVED" -ForegroundColor Green
    } elseif ($UsedPercent -lt 90) {
        Write-Host "WARNING: Disk usage improved but still elevated" -ForegroundColor Yellow
        Write-Host "Consider additional cleanup or capacity expansion" -ForegroundColor Yellow
    } else {
        Write-Host "WARNING: Disk usage still critical" -ForegroundColor Red
        Write-Host "Further investigation needed - logs may not be primary cause" -ForegroundColor Yellow
    }

    Write-Host ""
    Write-Host "=" * 60 -ForegroundColor Gray
    Write-Host "Cleanup operation completed successfully" -ForegroundColor Green
    Write-Host "Backup location: $BackupPath" -ForegroundColor Gray

} catch {
    Write-Host ""
    Write-Host "=" * 60 -ForegroundColor Red
    Write-Host "ERROR: Unexpected error occurred" -ForegroundColor Red
    Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host ""
    Write-Host "ROLLBACK INSTRUCTIONS:" -ForegroundColor Yellow
    Write-Host "1. Logs backed up to: $BackupPath" -ForegroundColor Gray
    Write-Host "2. To restore: Copy-Item '$BackupPath\\*' -Destination '$LogPath' -Force" -ForegroundColor Gray
    Write-Host "3. Contact system administrator if issue persists" -ForegroundColor Gray
    Write-Host "=" * 60 -ForegroundColor Red
    exit 1
}
""",
                "script_language": "powershell",
                "safety_checks": [
                    "Backup created before deletion at D:\\Backups\\IISLogs",
                    "Only deletes files older than 30 days (configurable threshold)",
                    "Preserves current day logs automatically",
                    "Includes Try-Catch error handling with detailed rollback guidance",
                    "Verifies path existence before any operations",
                    "Progress indicators and colored output for audit trail",
                    "File-by-file deletion with individual error handling",
                    "Post-cleanup verification of disk usage",
                ],
                "estimated_time": "2-3 minutes",
                "rollback_plan": "If issues occur, all deleted logs are backed up at D:\\Backups\\IISLogs. To restore, run: Copy-Item 'D:\\Backups\\IISLogs\\*' -Destination 'C:\\inetpub\\logs\\LogFiles' -Force. Script includes detailed error messages and graceful failure handling.",
            }
        }

    def load_sop_kb(self) -> Dict:
        """Load SOP knowledge base from data directory"""
        try:
            kb_path = os.path.join("..", "data", "sop_kb.json")
            with open(kb_path, "r") as f:
                return json.load(f)
        except FileNotFoundError:
            print("Warning: sop_kb.json not found, using empty knowledge base")
            return {}
        except json.JSONDecodeError as e:
            print(f"Warning: Failed to parse sop_kb.json: {e}")
            return {}

    def load_device_history(self, system: str) -> List[Dict]:
        """Load historical incidents for specific device"""
        try:
            history_path = os.path.join("..", "data", "device_history.json")
            with open(history_path, "r") as f:
                history = json.load(f)
                return history.get(system, [])
        except FileNotFoundError:
            print("Warning: device_history.json not found")
            return []
        except json.JSONDecodeError as e:
            print(f"Warning: Failed to parse device_history.json: {e}")
            return []

    def analyze_alert(self, alert: Alert) -> RemediationPlan:
        """
        Main analysis function using Claude 3.5 Sonnet on Bedrock
        Implements safety-first prompt engineering
        """

        # Check cache first for demo reliability
        if self.use_cache and alert.id in self.cached_responses:
            print(f"Using cached response for alert {alert.id}")
            cached = self.cached_responses[alert.id]
            return RemediationPlan(alert_id=alert.id, **cached)

        # Gather context from knowledge base and history
        sop_kb = self.load_sop_kb()
        device_history = self.load_device_history(alert.system)

        # Find relevant SOP for this alert type
        relevant_sop = self._find_relevant_sop(alert.alert_type, sop_kb)

        # Build context-aware prompt
        prompt_content = self._build_analysis_prompt(
            alert, relevant_sop, device_history
        )

        # Call Bedrock API with safety constraints
        try:
            print(
                f"Calling AWS Bedrock ({self.model_name}) to analyze alert {alert.id}..."
            )
            response_text = self._call_bedrock(prompt_content)
            plan = self._parse_remediation_plan(response_text, alert.id)
            print(f"Successfully generated remediation plan for {alert.id}")
            return plan

        except Exception as e:
            # Fallback to cached response if Bedrock fails
            print(f"Bedrock API error: {e}")
            if alert.id in self.cached_responses:
                print(f"Falling back to cached response for {alert.id}")
                cached = self.cached_responses[alert.id]
                return RemediationPlan(alert_id=alert.id, **cached)
            raise Exception(
                f"Analysis failed and no cached response available: {str(e)}"
            )

    def _find_relevant_sop(self, alert_type: str, sop_kb: Dict) -> Dict:
        """
        Find relevant SOP using simple keyword matching
        In production: use semantic search with embeddings
        """
        for sop_id, sop_data in sop_kb.items():
            triggers = sop_data.get("triggers", [])
            if any(trigger in alert_type.lower() for trigger in triggers):
                return sop_data
        return {}

    def _build_analysis_prompt(
        self, alert: Alert, sop: Dict, history: List[Dict]
    ) -> str:
        """
        Constructs the Claude prompt with full context
        Follows safety-first approach with explicit constraints
        """

        # Format historical context
        history_context = ""
        if history:
            recent = history[-3:]  # Last 3 incidents
            history_context = "Recent similar incidents on this system:\n"
            for h in recent:
                history_context += f"- {h['date']}: {h['issue']} → Resolved in {h['resolution_time']} min\n"
                history_context += f"  Action taken: {h['action_taken']}\n"
        else:
            history_context = "No historical incidents found for this system.\n"

        # Format SOP steps
        sop_steps = ""
        if sop:
            sop_steps = "Standard Operating Procedure:\n"
            sop_steps += f"Title: {sop.get('title', 'N/A')}\n"
            for i, step in enumerate(sop.get("steps", []), 1):
                sop_steps += f"{i}. {step}\n"

            if sop.get("safety_notes"):
                sop_steps += "\nSAFETY REQUIREMENTS FROM SOP:\n"
                for note in sop["safety_notes"]:
                    sop_steps += f"- {note}\n"
        else:
            sop_steps = "No specific SOP found for this alert type. Use general best practices.\n"

        # Main prompt with safety emphasis
        prompt = f"""You are an expert IT operations assistant specializing in alert triage and remediation for Windows Server environments.

ALERT DETAILS:
- Alert ID: {alert.id}
- Timestamp: {alert.timestamp}
- Severity: {alert.severity}
- Affected System: {alert.system} (Windows Server 2019)
- Alert Type: {alert.alert_type}
- Description: {alert.description}
- Metrics: {json.dumps(alert.metrics, indent=2)}

HISTORICAL CONTEXT:
{history_context}

KNOWLEDGE BASE:
{sop_steps}

YOUR TASK:
1. Analyze the root cause of this alert using all provided context
2. Provide a confidence score (0.0 to 1.0, where 1.0 = 100% confident)
3. Explain your reasoning clearly, referencing historical data and metrics
4. Generate a detailed step-by-step remediation plan in plain English
5. Write a complete, production-ready PowerShell script to execute the remediation

CRITICAL SAFETY REQUIREMENTS FOR THE SCRIPT:
- NEVER include destructive commands without explicit safeguards
- ALWAYS include backup steps before any modifications
- Use Write-Host with color coding for clear logging at each step
- Include comprehensive Try-Catch error handling blocks
- Verify operations with Test-Path or equivalent checks before proceeding
- Provide progress indicators for long-running operations
- Include post-operation verification to confirm success
- Add detailed comments explaining each section
- Provide rollback instructions in case of failure
- Exit with appropriate exit codes (0 = success, 1 = error)

OUTPUT FORMAT - RESPOND WITH VALID JSON ONLY:
{{
    "root_cause": "Brief root cause explanation (1-2 sentences)",
    "confidence": 0.92,
    "reasoning": "Detailed explanation of why you believe this is the cause. Reference historical patterns, current metrics, and SOP guidance. Explain your confidence level.",
    "remediation_steps": [
        "Step 1: Clear action with expected outcome",
        "Step 2: Next action with verification step",
        "Continue with all necessary steps in logical order"
    ],
    "script": "# Complete PowerShell script\\n# With extensive comments\\n# Include all safety measures listed above\\n...",
    "safety_checks": [
        "Specific safety measure 1 with detail",
        "Specific safety measure 2 explaining protection",
        "List ALL safety mechanisms implemented in the script"
    ],
    "estimated_execution_time": "2-3 minutes",
    "rollback_plan": "Detailed step-by-step instructions on how to undo changes if something goes wrong, including specific commands"
}}

IMPORTANT FORMATTING RULES:
1. Respond ONLY with the JSON object
2. Do NOT include markdown formatting or code blocks
3. Ensure all JSON is valid and properly escaped
4. PowerShell script should be in the "script" field as a single string with \\n for newlines
5. Do NOT wrap the JSON in ```json``` or any other markers

Generate the remediation plan now:"""

        return prompt

    def _call_bedrock(self, prompt: str) -> str:
        """
        Call AWS Bedrock API with Amazon Nova Pro
        Uses the Messages API format required by Nova models
        """
        try:
            # Prepare request body for Amazon Nova
            # Nova uses a similar format to Claude but with different parameter names
            request_body = {
                "messages": [{"role": "user", "content": [{"text": prompt}]}],
                "inferenceConfig": {
                    "max_new_tokens": 4000,
                    "temperature": 0.3,  # Lower for more consistent, focused responses
                    "top_p": 0.95,
                },
            }

            # Call Bedrock API
            response = self.bedrock.invoke_model(
                modelId=self.model_id, body=json.dumps(request_body)
            )

            # Parse response
            response_body = json.loads(response["body"].read())

            # Extract text from Nova's response
            # Nova returns: {"output": {"message": {"content": [{"text": "..."}]}}}
            if "output" in response_body and "message" in response_body["output"]:
                message = response_body["output"]["message"]
                if "content" in message and len(message["content"]) > 0:
                    response_text = message["content"][0]["text"]
                    return response_text

            raise Exception("Bedrock response missing content")

        except ClientError as e:
            error_code = e.response["Error"]["Code"]
            error_message = e.response["Error"]["Message"]

            # Handle specific AWS errors
            if error_code == "ThrottlingException":
                raise Exception(f"AWS Bedrock rate limit exceeded: {error_message}")
            elif error_code == "ModelNotReadyException":
                raise Exception(f"Model {self.model_id} is not ready: {error_message}")
            elif error_code == "AccessDeniedException":
                raise Exception(
                    f"Access denied to AWS Bedrock. Please verify:\n"
                    f"1. AWS credentials are correct\n"
                    f"2. IAM user has bedrock:InvokeModel permission\n"
                    f"3. Model {self.model_id} is enabled in your AWS account\n"
                    f"Error: {error_message}"
                )
            else:
                raise Exception(
                    f"AWS Bedrock API error ({error_code}): {error_message}"
                )

        except Exception as e:
            raise Exception(f"Bedrock API call failed: {str(e)}")

    def _parse_remediation_plan(
        self, bedrock_response: str, alert_id: str
    ) -> RemediationPlan:
        """
        Parse Claude JSON response into RemediationPlan object
        Handles various response formats and malformed JSON
        """
        try:
            # Clean response - remove markdown if present
            response_text = bedrock_response.strip()

            # Remove code block markers if Claude added them despite instructions
            if "```json" in response_text:
                response_text = (
                    response_text.split("```json")[1].split("```")[0].strip()
                )
            elif "```" in response_text:
                response_text = response_text.split("```")[1].split("```")[0].strip()

            # Parse JSON
            data = json.loads(response_text)

            # Validate required fields
            required_fields = [
                "root_cause",
                "confidence",
                "remediation_steps",
                "script",
            ]
            missing = [f for f in required_fields if f not in data]
            if missing:
                raise KeyError(f"Missing required fields: {missing}")

            # Create RemediationPlan object
            return RemediationPlan(
                alert_id=alert_id,
                root_cause=data["root_cause"],
                confidence=float(data["confidence"]),
                reasoning=data.get("reasoning", "No detailed reasoning provided"),
                steps=data["remediation_steps"],
                script=data["script"],
                script_language="powershell",
                safety_checks=data.get("safety_checks", []),
                estimated_time=data.get("estimated_execution_time", "Unknown"),
                rollback_plan=data.get(
                    "rollback_plan", "No specific rollback plan provided"
                ),
            )

        except json.JSONDecodeError as e:
            error_preview = (
                bedrock_response[:300]
                if len(bedrock_response) > 300
                else bedrock_response
            )
            raise Exception(
                f"Failed to parse Bedrock response as JSON: {str(e)}\n"
                f"Response preview: {error_preview}..."
            )
        except KeyError as e:
            raise Exception(f"Bedrock response missing required field: {str(e)}")
        except ValueError as e:
            raise Exception(f"Invalid data type in Bedrock response: {str(e)}")
        except Exception as e:
            raise Exception(f"Error parsing Bedrock response: {str(e)}")
